rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * # Firestore Security Rules
     *
     * ## Core Philosophy
     * This ruleset implements a hybrid security model designed for flexibility and security.
     * The core principles are:
     * 1.  **User Ownership**: Data directly related to a user, such as their member profile or
     *     membership card design, is strictly owned and controlled by that user.
     * 2.  **Role-Based Access Control (RBAC)**: A dedicated `roles_admin` collection grants
     *     administrative privileges. Admins have broad permissions to manage platform-wide
     *     data like news articles, receipts, and user roles.
     * 3.  **Public Access**: Collections intended for public consumption, like news articles,
     *     are readable by anyone, including unauthenticated users.
     *
     * ## Data Structure
     * Data is organized into top-level collections, each representing a distinct entity.
     * This structural segregation ensures that security rules for one collection do not
     * impact another. For example, private `/members` data is kept separate from public
     * `/news_articles`. Administrative roles are managed via document existence checks in
     * the `/roles_admin` collection, which is a highly performant and secure pattern.
     *
     * ## Key Security Decisions
     * - **Deny by Default**: Access is implicitly denied unless an `allow` rule explicitly grants it.
     * - **No User Listing**: Listing users from `/members` or `/admins` collections is disabled
     *   to protect user privacy and prevent data scraping.
     * - **Donation Workflow**: Any signed-in user can create a donation, but only administrators
     *   can update (e.g., verify) or delete them, ensuring a secure verification process.
     * - **Authorization over Validation**: In this prototyping stage, rules focus strictly on
     *   *who* can access data, not the specific *shape* of the data. Validation is limited
     *   to fields critical for establishing ownership and relational integrity.
     *
     * ## Denormalization for Authorization
     * To create simple, fast, and secure rules, data required for authorization is denormalized
     * onto the documents being secured. For example, `Donation` and `MembershipCardDesign`
     * documents contain a `memberId` field. This allows rules to check for ownership directly on
     * the document without needing slow and costly `get()` calls to other collections.
     *
     * ## Structural Segregation
     * The data model uses separate collections for data with different security requirements.
     * For instance, public content (`/news_articles`) is in a different collection from
     * private user data (`/members`). This prevents accidental data leakage and simplifies
     * rules for list operations.
     */

    // --------------------------------------------------------------------------
    // Helper Functions
    // --------------------------------------------------------------------------

    /**
     * Checks if a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the authenticated user's UID matches the provided userId.
     * This is the primary function for enforcing document ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks if the authenticated user has administrative privileges.
     * An admin is defined by the existence of a document in the /roles_admin collection
     * with their UID as the document ID.
     */
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /**
     * Ensures that a document being updated or deleted actually exists.
     * This prevents unauthorized actions on non-existent paths.
     */
    function isExistingDoc() {
      return resource != null;
    }

    /**
     * Combines an admin check with an existence check for update/delete operations.
     */
    function isExistingAdmin() {
      return isAdmin() && isExistingDoc();
    }

    /**
     * On create, validates that the new document's owner field matches the creator.
     */
    function createdByOwner(ownerField) {
      return isSignedIn() && request.resource.data[ownerField] == request.auth.uid;
    }

    /**
     * On update, ensures an ownership field is not changed.
     */
    function ownerIsImmutable(ownerField) {
      return request.resource.data[ownerField] == resource.data[ownerField];
    }

    // --------------------------------------------------------------------------
    // Collection Rules
    // --------------------------------------------------------------------------

    /**
     * @description Controls access to member profiles.
     * @path /members/{memberId}
     * @allow A logged-in user (auth.uid='user123') creating their own profile at `/members/user123`. (create)
     * @deny A logged-in user (auth.uid='user456') trying to read a profile at `/members/user123`. (get)
     * @principle Restricts access to a user's own data tree.
     */
    match /members/{memberId} {
      allow get: if isOwner(memberId) || isAdmin();
      allow list: if isAdmin();
      allow create: if isOwner(memberId) && request.resource.data.id == memberId;
      allow update: if (isOwner(memberId) || isAdmin()) && isExistingDoc() && ownerIsImmutable('id');
      allow delete: if isAdmin() && isExistingDoc();

      match /payments/{paymentId} {
        allow get: if isOwner(memberId) || isAdmin();
        allow list: if isOwner(memberId) || isAdmin();
        allow create: if isOwner(memberId) && request.resource.data.memberId == memberId;
        allow update: if (isOwner(memberId) || isAdmin()) && isExistingDoc() && ownerIsImmutable('memberId');
        allow delete: if (isOwner(memberId) || isAdmin()) && isExistingDoc();
      }
    }

    /**
     * @description Controls access to donation records.
     * @path /donations/{donationId}
     * @allow Any signed-in user creating a new donation with their own `memberId`. (create)
     * @deny A user trying to update or delete a donation after creation. (update, delete)
     * @principle Allows public creation but reserves management (update, delete) for administrators.
     */
    match /donations/{donationId} {
      allow get: if (isOwner(resource.data.memberId) || isAdmin());
      allow list: if isAdmin();
      allow create: if createdByOwner('memberId');
      allow update: if isExistingAdmin();
      allow delete: if isExistingAdmin();
    }

    /**
     * @description Controls access to the list of admins. For internal admin management.
     * @path /admins/{adminId}
     * @allow An admin reading another admin's document. (get)
     * @deny A non-admin user trying to read any document in this collection. (get, list)
     * @principle Secures administrative data, making it accessible only to other admins.
     */
    match /admins/{adminId} {
      allow get: if isAdmin();
      allow list: if isAdmin();
      allow create: if isAdmin();
      allow update: if isExistingAdmin();
      allow delete: if isExistingAdmin();
    }

    /**
     * @description Controls access to public-facing news articles.
     * @path /news_articles/{newsArticleId}
     * @allow Any user, including anonymous ones, reading a news article. (get, list)
     * @deny A non-admin user trying to create or delete a news article. (create, delete)
     * @principle Implements a "Public Read with Admin-Only Writes" pattern for content management.
     */
    match /news_articles/{newsArticleId} {
      allow get: if true;
      allow list: if true;
      allow create: if isAdmin();
      allow update: if isExistingAdmin();
      allow delete: if isExistingAdmin();
    }

    /**
     * @description Controls access to user-created membership card designs.
     * @path /membership_card_designs/{membershipCardDesignId}
     * @allow A user (auth.uid='user123') creating a design with `memberId: 'user123'`. (create)
     * @deny Any user attempting to list all available designs. (list)
     * @principle Enforces document ownership for reads and writes. List is disabled because queries cannot be securely filtered by owner at the rules level for a top-level collection.
     */
    match /membership_card_designs/{membershipCardDesignId} {
      allow get: if isOwner(resource.data.memberId);
      allow list: if false;
      allow create: if createdByOwner('memberId');
      allow update: if isOwner(resource.data.memberId) && isExistingDoc() && ownerIsImmutable('memberId');
      allow delete: if isOwner(resource.data.memberId) && isExistingDoc();
    }

    /**
     * @description Controls access to donation receipts.
     * @path /receipts/{receiptId}
     * @allow An admin user reading or creating a receipt. (get, create)
     * @deny Any non-admin user attempting to access receipts. (get, list, write)
     * @principle Restricts sensitive financial documents to administrative access only.
     */
    match /receipts/{receiptId} {
      allow get: if isAdmin();
      allow list: if isAdmin();
      allow create: if isAdmin();
      allow update: if isExistingAdmin();
      allow delete: if isExistingAdmin();
    }

    /**
     * @description Manages admin role assignments. The existence of a document here grants admin rights.
     * @path /roles_admin/{userId}
     * @allow An admin adding another user ('user456') as an admin by creating `/roles_admin/user456`. (create)
     * @deny A non-admin trying to grant themselves admin rights. (create, update)
     * @principle Secures the role management system, ensuring only admins can modify roles.
     */
    match /roles_admin/{userId} {
      allow get: if isAdmin();
      allow list: if isAdmin();
      allow create: if isAdmin();
      allow update: if false;
      allow delete: if isExistingAdmin();
    }
  }
}
service firebase.storage {
  match /b/{bucket}/o {
    // Users can write to their own profile photo path
    match /profile_photos/{userId}/{allPaths=**} {
      allow write: if request.auth != null && request.auth.uid == userId;
      allow read: if true; // Public read for profile photos
    }

    // Users can write their own payment proofs, but they are not public
    match /payment_proofs/{userId}/{allPaths=**} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // Users can write their own documents, but they are not public
    match /documents/{userId}/{allPaths=**} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }
  }
}
